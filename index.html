<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Leaflet + OSM + GPX (ë²„íŠ¼ í†µí•© + ì˜µì…˜ + ì˜¤ë²„ë·° + ë’¤ë¡œê°€ê¸°)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.7.0/gpx.min.js"></script>
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    .control{
      position: fixed; z-index: 1000; left: 10px; top: 8px;
      background: rgba(255,255,255,.96); backdrop-filter: saturate(120%) blur(2px);
      padding: 10px 12px; border-radius: 10px; box-shadow: 0 8px 24px rgba(0,0,0,.2);
      font: 14px/1.2 system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans KR",sans-serif;
    }
    .control h1{ font-size:14px; margin:0 0 8px; font-weight:700; }
    .control .row{ display:flex; gap:10px; align-items:center; margin-top:6px; flex-wrap:wrap; }
    .control input[type="file"]{ font-size:12px; }
    .control button{
      appearance:none; border:1px solid #e2e8f0; background:#0ea5e9; color:#fff;
      padding:6px 10px; border-radius:8px; cursor:pointer; font-weight:700;
    }
    .control button:disabled{ background:#94a3b8; cursor:not-allowed; }
    .control .chk { display:flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid #e2e8f0; border-radius:10px; background:#fff; }
    .control .slider-wrap{ display:flex; justify-content: space-between; align-items:center; gap:8px; padding:6px 8px; border:1px solid #e2e8f0; border-radius:10px; background:#fff; }
    .control .slider-wrap label{ background:transparent; color:#0f172a; border:0; padding:0; font-weight:800; }
    .control input[type="range"]{ width:360px; accent-color:#0ea5e9; }
    .control .val{ min-width:56px; text-align:right; font-weight:800; color:#0f172a; }

    .marker-pill{
      position:relative; display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius:999px;
      font:600 12px/1.2 "Segoe UI",system-ui,-apple-system,"Noto Sans KR",sans-serif;
      color:#0f172a; background:#fff; border:1px solid rgba(2,6,23,.1);
      box-shadow:0 4px 10px rgba(2,6,23,.12); transform:translate(-50%,-100%);
      white-space:nowrap; pointer-events:none;
    }
    .marker-pill::after{
      content:""; position:absolute; left:50%; bottom:-6px; translate:-50% 0;
      border:6px solid transparent; border-top-color:#fff; filter:drop-shadow(0 -1px 0 rgba(2,6,23,.08));
    }
    .marker-start span:first-child{ color:#16a34a; }
    .marker-end   span:first-child{ color:#ef4444; }

    .hud{
      position:relative; display:inline-flex; flex-direction:column; gap:6px;
      padding:8px 10px; border-radius:10px; background:rgba(255,255,255,.96);
      border:1px solid #e2e8f0; box-shadow:0 6px 16px rgba(0,0,0,.12);
      font:12px/1.2 system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans KR",sans-serif; color:#0f172a;
      transform:translate(-50%, calc(-100% - 44px)); pointer-events:none; white-space:nowrap;
      font-variant-numeric: tabular-nums; -moz-font-feature-settings:"tnum"; -webkit-font-feature-settings:"tnum"; font-feature-settings:"tnum";
    }
    .hud .chip{ display:grid; grid-template-columns:18px 56px minmax(54px, max-content); column-gap:8px; align-items:center; }
    .hud .label{ opacity:.7; }
    .hud .val{ text-align:right; font-weight:700; }

    .overview{
      position: fixed; z-index: 600; left: 12px; bottom: 12px;
      display: grid; gap: 6px;
      padding: 8px; border-radius: 10px; background: rgba(255,255,255,.96);
      border: 1px solid #e2e8f0; box-shadow: 0 6px 18px rgba(0,0,0,.18);
      font: 12px system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans KR",sans-serif; color:#0f172a;
    }
    #miniMap{
      width: 220px; height: 150px; border-radius: 8px; overflow: hidden;
      border: 1px solid #e2e8f0;
    }
    .ovr-legend{ display:flex; padding: 0 10px; gap:10px; align-items:center; justify-content:space-between; }
    .ovr-legend .key{ display:inline-block; width:25px; height:3px; background:#ef4444; border-radius:999px; }
    .ovr-legend .dot{ display:inline-block; width:10px; height:10px; border-radius:50%; background:#0ea5e9; outline:0.5px solid #1f2937; }

    @media screen and (max-width: 640px) {
      .control{
        left:10px;
        padding:10px 10px;
        border-radius:5px;
      }

      .control .row{
        font-size:12px;
        margin:6px 0;
        padding:0;
        border:0;                 /* rowì— ê±¸ë¦° ë³´ë”ë„ ì œê±° */
      }

      .control .chk,
      .control .slider-wrap  {
        padding: 0 ;
        border:0;                 /* ì—¬ê¸°! ìì† ì„ íƒìë¡œ ì •í™•íˆ ì§€ì • */
        box-shadow:none;          /* ë³´ë”ì²˜ëŸ¼ ë³´ì´ëŠ” ê·¸ë¦¼ìë„ ì œê±° */
        outline:0;
      }
      #fitBtn{ display:none; }
      .control input[type="range"]{ max-width: 300px; }
      .control button{ padding:3px 8px; font-size:13px; font-weight:500; }
    }


  </style>
</head>
<body>
  <div class="control">
    <h1>GPX ReLiveView</h1>
    <div class="row">
      <input type="file" id="gpxFile" accept=".gpx" />
      <button id="fitBtn" disabled>ì „ì²´ ê²½ë¡œ ë³´ê¸°</button>
      <button id="playBtn" disabled>â–¶ ì¬ìƒ</button>
      <!-- â–¶ ë’¤ë¡œê°€ê¸° ë²„íŠ¼ (ì¼ì‹œì •ì§€ ì‹œ í™œì„±í™”) -->
      <button id="backBtn" disabled>âŸ² ë’¤ë¡œê°€ê¸°</button>
    </div>
    <div class="row">
      <label class="chk"><input type="checkbox" id="optRealSpeed"> ì‹¤ì œ ì£¼í–‰ì†ë„ ì ìš©</label>
      <label class="chk"><input type="checkbox" id="optSpeedCtl" checked> ë°°ì† ì¡°ì •</label>
      <!-- â˜… ì¶”ê°€: ê²½ë¡œ ìƒ‰ìƒ ëª¨ë“œ -->
      <div class="row">
        <label class="chk" style="gap:8px; border:0; background:transparent; padding:0;">
            <span style="font-weight:800;">ê²½ë¡œ ìƒ‰ìƒ</span>
            <select id="colorMode" style="padding:6px 10px; border:1px solid #e2e8f0; border-radius:8px;">
                <option value="mono">ë‹¨ìƒ‰(ê¸°ë³¸)</option>
                <option value="ele">ê³ ë„</option>
                <option value="spd">ì†ë„</option>
                <option value="hr">ì‹¬ë°•</option>
                <option value="cad">ì¼€ì´ë˜ìŠ¤</option>
                <option value="pwr">íŒŒì›Œ</option>
            </select>
        </label>
      </div>
    </div>

    <div class="row slider-wrap">
      <label for="speedRange">ë°°ì†</label>
      <input type="range" id="speedRange" min="0" max="100" step="0.1" value="1" />
      <span class="val"><span id="speedValue">1.0</span>Ã—</span>
    </div>
  </div>

  <div id="map"></div>

  <div class="overview">
    <div id="miniMap" aria-label="ì˜¤ë²„ë·° ì§€ë„"></div>
    <div class="ovr-legend">
      <span><span class="key"></span> ì „ì²´ê²½ë¡œ</span>
      <span><span class="dot"></span> í˜„ì¬ìœ„ì¹˜</span>
    </div>
  </div>

  <script>
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì „ì—­ ìƒíƒœ â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let lastAbsMs = NaN; // â˜… ë§ˆì§€ë§‰ìœ¼ë¡œ ë Œë”í•œ ì ˆëŒ€ ì‹œê°(ms)ì„ ì „ì—­ìœ¼ë¡œ ë³´ì¡´
    let map, gpxLayer=null, marker=null, hudMarker=null, animReq=null, stepRef=null;
    let paused=false, lastFrameTime=0, mode='distance';
    let speed=1;
    const BASE_DURATION=8000;

    // â˜… ë³€ê²½: ë’¤ë¡œê°€ê¸° ë™ì‘ì„ "ê±°ë¦¬ 100m" ë‹¨ìœ„ë¡œ
    const BACK_STEP_METERS = 100; // â† 100 m ê³ ì •                        // â˜… ë³€ê²½

    // ì œê±°: ê¸°ì¡´ ë¶„ê¸°ìš© ìƒìˆ˜ (5%/5ì´ˆ)
    // const BACK_STEP_FRAC = 0.05;
    // const BACK_STEP_MS   = 5000;

    let distPts=[], distCum=[], distScaled=0;
    let totalDistMeters = 0;       // ì „ì²´ ê±°ë¦¬(m)                         // â˜… ë³€ê²½
    let curDistMeters   = 0;       // í˜„ì¬ ëˆ„ì  ê±°ë¦¬(m)                     // â˜… ë³€ê²½
    
    let currentIndex = 0;

    let timeAnim=null; // { pts, t0, tEnd, totalMs, tArr, elapsed }

    // ì˜¤ë²„ë·°
    let miniMap, miniRoute=null, miniMarker=null, miniBounds=null;

    // â˜… ì¶”ê°€: ê²½ë¡œ ì»¬ëŸ¬ë§ ê´€ë ¨ ì „ì—­
    let gradientGroup = null;   // ì„¸ê·¸ë¨¼íŠ¸ í´ë¦¬ë¼ì¸ì„ ë‹´ëŠ” ê·¸ë£¹
    let colorModeEl   = null;   // ë“œë¡­ë‹¤ìš´ ì—˜ë¦¬ë¨¼íŠ¸
    let statRange = {           // ì»¬ëŸ¬ ìŠ¤ì¼€ì¼ìš© ìµœì†Œ/ìµœëŒ€ê°’
    ele: {min:NaN, max:NaN},
    spd: {min:NaN, max:NaN},
    hr : {min:NaN, max:NaN},
    cad: {min:NaN, max:NaN},
    pwr: {min:NaN, max:NaN},
    };


    // â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì§€ë„ ì´ˆê¸°í™” â”€â”€â”€â”€â”€â”€â”€â”€â”€
    map = L.map('map', { zoomControl:false }).setView([36.5,127.9], 7);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom:19, attribution:'&copy; <a href="https://www.openstreetmap.org/">OSM</a> contributors'
    }).addTo(map);

    // â˜… ì¶”ê°€: ê·¸ë¼ë°ì´ì…˜ ë¼ì¸ìš© pane(íƒ€ì¼/ê¸°íƒ€ ì˜¤ë²„ë ˆì´ ìœ„ì— í™•ì‹¤íˆ í‘œì‹œ)
    map.createPane('routePane');
    map.getPane('routePane').style.zIndex = 420;

    miniMap = L.map('miniMap', {
      attributionControl:false, zoomControl:false,
      dragging:false, scrollWheelZoom:false, doubleClickZoom:false,
      boxZoom:false, keyboard:false, tap:false, touchZoom:false
    }).setView([36.5,127.9], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom:19 }).addTo(miniMap);

    const startDivIcon = L.divIcon({ className:"", html:`<div class="marker-pill marker-start"><span>ğŸŸ¢</span><span>START</span></div>` });
    const endDivIcon   = L.divIcon({ className:"", html:`<div class="marker-pill marker-end"><span>ğŸ</span><span>FINISH</span></div>` });

    const iconRight = L.icon({ iconUrl:'icons/cycling-right.png', iconSize:[40,40], iconAnchor:[14,28] });
    const iconLeft  = L.icon({ iconUrl:'icons/cycling-left.png',  iconSize:[40,40], iconAnchor:[14,28] });

    const hudDivIcon = L.divIcon({
      className:"",
      html:`<div id="hud" class="hud">
              <span class="chip"><span>ğŸš´</span><span class="label">ì†ë„</span><span class="val" id="hudSpd">â€”</span></span>
              <span class="chip"><span>â¤ï¸</span><span class="label">ì‹¬ë°•</span><span class="val" id="hudHr">â€”</span></span>
              <span class="chip"><span>â›°</span><span class="label">ê³ ë„</span><span class="val" id="hudEle">â€”</span></span>
              <span class="chip"><span>ğŸ”</span><span class="label">ì¼€ì´ë˜ìŠ¤</span><span class="val" id="hudCad">â€”</span></span>
              <span class="chip"><span>âš¡</span><span class="label">íŒŒì›Œ</span><span class="val" id="hudPwr">â€”</span></span>
              <!-- â˜… ì¶”ê°€: ëˆ„ì ê±°ë¦¬ (íŒŒì›Œì™€ í˜„ì¬ì‹œê° ì‚¬ì´) -->
              <span class="chip"><span>ğŸ“</span><span class="label">ëˆ„ì ê±°ë¦¬</span><span class="val" id="hudDist">0.00 km</span></span> <!-- â˜… ë³€ê²½ -->
              <span class="chip"><span>ğŸ•’</span><span class="label">í˜„ì¬ì‹œê°</span><span class="val" id="hudTime">â€”</span></span>
            </div>`
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€ UI ì—˜ë¦¬ë¨¼íŠ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const fitBtn = document.getElementById('fitBtn');
    const playBtn = document.getElementById('playBtn');
    const backBtn = document.getElementById('backBtn');
    const optRealSpeed = document.getElementById('optRealSpeed');
    const optSpeedCtl  = document.getElementById('optSpeedCtl');
    const speedRange = document.getElementById('speedRange');
    const speedValue = document.getElementById('speedValue');

    function applySpeedCtlUI() {
      const enabled = optSpeedCtl.checked;
      speedRange.disabled = !enabled;
      if (!enabled) { speed = 1; speedRange.value = "1"; speedValue.textContent = "1.0"; }
    }
    optSpeedCtl.addEventListener('change', applySpeedCtlUI);
    applySpeedCtlUI();

    speedRange.addEventListener('input', (e)=>{
      const v = parseFloat(e.target.value);
      speed = Number.isFinite(v) ? v : 1;
      speedValue.textContent = speed.toFixed(1);
    });

    // íŒŒì¼ ë¡œë“œ
    document.getElementById('gpxFile').addEventListener('change',(e)=>{
      const file = e.target.files?.[0];
      if (!file) return;
      resetAll();

      const reader = new FileReader();
      reader.onload = (evt)=>{
        const gpxText = evt.target.result;

        distPts = parseGpxPoints(gpxText);
        distCum = buildCumDist(distPts);
        totalDistMeters = distCum.length ? distCum[distCum.length-1] : 0;                // â˜… ë³€ê²½
        curDistMeters = 0;                                                               // â˜… ë³€ê²½

        // â˜… ì¶”ê°€: ì»¬ëŸ¬ ìŠ¤ì¼€ì¼ìš© í†µê³„ ê³„ì‚°(ì†ë„ëŠ” ì„¸ê·¸ë¨¼íŠ¸ ì†ë„ë¡œ ì‚°ì¶œ)
        computeStatRange(distPts);

        // â˜… ì¶”ê°€: ë“œë¡­ë‹¤ìš´ í•¸ë“¤ëŸ¬ ì¤€ë¹„
        if (!colorModeEl) colorModeEl = document.getElementById('colorMode');
        if (colorModeEl) {
        colorModeEl.onchange = () => buildGradientRoute(colorModeEl.value || 'mono');
        }

        // â˜… ì¶”ê°€: ì´ˆê¸° ê·¸ë¦¬ê¸°(ë‹¨ìƒ‰)
        buildGradientRoute('mono');


        // ì˜¤ë²„ë·° ë¼ì¸
        if (miniRoute){ miniMap.removeLayer(miniRoute); miniRoute=null; }
        if (distPts.length >= 2){
          const latlngs = distPts.map(p=>[p.lat,p.lng]);
          miniRoute = L.polyline(latlngs, { color:'#ef4444', weight:3, opacity:0.9 }).addTo(miniMap);
          miniBounds = miniRoute.getBounds();
          miniMap.fitBounds(miniBounds, { padding:[6,6] });
        }

        gpxLayer = new L.GPX(gpxText, {
          async:true,
          marker_options:{ startIcon:startDivIcon, endIcon:endDivIcon, startIconUrl:null, endIconUrl:null, shadowUrl:null },
          // â˜… ê¸°ë³¸ ë‹¨ìƒ‰ ë¼ì¸ì€ ìˆ¨ê¸°ê³ , ì»¤ìŠ¤í…€ ì„¸ê·¸ë¨¼íŠ¸ ë¼ì¸ì„ ë³„ë„ ë ˆì´ì–´ë¡œ ê·¸ë¦¼
          polyline_options:{ color:'#ef4444', weight:4, opacity:0 }
        })
        .on('loaded', (ev)=>{
          map.fitBounds(ev.target.getBounds(), { padding:[40,40] });

          const initialIcon = decideInitialIcon(distPts);
          marker = L.marker(map.getCenter(),{ title:'GPX Marker', icon:initialIcon }).addTo(map);
          hudMarker = L.marker(map.getCenter(),{ icon:hudDivIcon, interactive:false, keyboard:false }).addTo(map);

          // ì˜¤ë²„ë·° í˜„ì¬ìœ„ì¹˜ ë§ˆì»¤
          const c = map.getCenter();
          if (miniMarker){ miniMap.removeLayer(miniMarker); }
          miniMarker = L.circleMarker([c.lat, c.lng], {
            radius:4, color:'#1f2937', weight:2, fillColor:'#0ea5e9', fillOpacity:1
          }).addTo(miniMap);

          const ok = distPts.length >= 2;
          fitBtn.disabled = !ok;
          playBtn.disabled = !ok;
          backBtn.disabled = true; // ì‹œì‘ì€ ë¹„í™œì„±
          setPlayButton(false);
        })
        .addTo(map);
      };
      reader.readAsText(file);
    });

    // ê²½ë¡œ ë§ì¶¤
    fitBtn.addEventListener('click', ()=>{
      if (!gpxLayer) return;
      map.fitBounds(gpxLayer.getBounds(), { padding:[40,40] });
      const c = map.getCenter();
      if (marker) marker.setLatLng(c);
      if (hudMarker) hudMarker.setLatLng(c);
    });

    function setPlayButton(isPlaying){
      playBtn.textContent = isPlaying ? "â¸ ì¼ì‹œì •ì§€" : "â–¶ ì¬ìƒ";

      // ì• ë‹ˆ í”„ë ˆì„ ì •ë¦¬(ê²½í•© ë°©ì§€)
      if (!isPlaying) cancelAnimFrameIfAny();

      // ì¼ì‹œì •ì§€ + ë°ì´í„° ì¤€ë¹„ë¨ì¼ ë•Œë§Œ ë’¤ë¡œê°€ê¸° ê°€ëŠ¥
      const canBack = !isPlaying && distCum && distCum.length >= 2 && totalDistMeters > 0;
      backBtn.disabled = !canBack;
    }



    // â–¶ ë’¤ë¡œê°€ê¸° ë™ì‘ (í•­ìƒ "ê±°ë¦¬ 100m" ê¸°ì¤€ìœ¼ë¡œ ì´ë™)                         // â˜… ë³€ê²½
    // ì¤‘ë³µí´ë¦­ ë””ë°”ìš´ìŠ¤ + RAF ê²½í•© ì œê±° + plateau ì²˜ë¦¬ + "ì§„ì§œ ë’¤ë¡œ" ë³´ì¥
    let backLastTs = 0;

    backBtn.addEventListener('click', ()=>{
      if (backBtn.disabled) return;
      if (!Array.isArray(distCum) || distCum.length < 2 || !Number.isFinite(totalDistMeters) || totalDistMeters <= 0) return;

      const now = performance.now();
      if (now - backLastTs < 120) return; // 120ms ë””ë°”ìš´ìŠ¤
      backLastTs = now;

      cancelAnimFrameIfAny(); // ì§„í–‰ì¤‘ ì• ë‹ˆ ì·¨ì†Œ(ê²½í•© ë°©ì§€)

      // í˜„ì¬ ëˆ„ì ê±°ë¦¬ ê¸°ì¤€ìœ¼ë¡œ 100 m ë’¤ë¡œ
      const nowDist = getCurrentDistMeters();
      const target  = Math.max(0, nowDist - BACK_STEP_METERS);

      // í˜„ì¬ ì¸ë±ìŠ¤ë¥¼ íŒíŠ¸ë¡œ ì‚¬ìš©(ì—†ìœ¼ë©´ í˜„ì¬ ê±°ë¦¬ë¡œ ì—­ì‚°)
      const hintIdx = Number.isInteger(currentIndex) ? currentIndex : findIndexAtDistance(distCum, nowDist, null);

      // í•­ìƒ hintë³´ë‹¤ ì•ìª½(ì‘ì€ ì¸ë±ìŠ¤)ìœ¼ë¡œ ìŠ¤ëƒ…í•´ ì‹¤ì œ ë’¤ë¡œê°ì„ ë³´ì¥
      const idx = findIndexAtDistance(distCum, target, hintIdx);

      if (idx >= 0) renderAtIndex(idx);
      else renderAtDistanceMeters(target - 1e-3); // í´ë°±

      // âŸµ [ìˆ˜ì • 2] ì‹œê°„ ëª¨ë“œì¼ ë•Œ, ë°©ê¸ˆ ë Œë”ëœ ì ˆëŒ€ì‹œê°(lastAbsMs)ì„ ê¸°ì¤€ìœ¼ë¡œ ì¬ê°œ ì˜¤í”„ì…‹ì„ ë™ê¸°í™”
      if (mode === 'time' && timeAnim && Number.isFinite(lastAbsMs)) {
        timeAnim.elapsed = clamp(lastAbsMs - timeAnim.t0, 0, timeAnim.totalMs);
      }

    });

    

    playBtn.addEventListener('click', ()=>{
      if (!marker || distPts.length < 2) return;

      if (!stepRef){
        paused = false;
        lastFrameTime = performance.now();

        // â˜… ì¶”ê°€: ì™„ì£¼ ìƒíƒœë©´ 'ì²˜ìŒë¶€í„°' ì¬ìƒí•˜ê¸° ìœ„í•´ ì¦‰ì‹œ ì‹œì‘ì ìœ¼ë¡œ ì´ë™+ë¦¬ì…‹
        const atEnd = isAtEnd();
        let resumeMs;
        if (atEnd) {
          renderAtIndex(0);   // ë§ˆì»¤/ë¯¸ë‹ˆë§µì„ ì‹œì‘ ì§€ì ìœ¼ë¡œ ì¦‰ì‹œ ì´ë™
          resumeMs  = 0;      // ê±°ë¦¬ ëª¨ë“œ ì§„í–‰ë„ ë¦¬ì…‹
          lastAbsMs = NaN;    // ì‹œê°„ ë³µì›ê°’ ì œê±°
          if (timeAnim) timeAnim.elapsed = 0; // ì‹œê°„ ëª¨ë“œ ì§„í–‰ë„ ë¦¬ì…‹
        } else {
          // ì¢…ë£Œê°€ ì•„ë‹ˆë©´ 'í˜„ì¬ ìœ„ì¹˜'ì—ì„œ ì´ì–´ì„œ
          resumeMs = (Number.isFinite(totalDistMeters) && totalDistMeters > 0)
            ? (getCurrentDistMeters() / totalDistMeters) * BASE_DURATION
            : distScaled; // ì•ˆì „ì¥ì¹˜
        }
        distScaled = resumeMs;

        if (optRealSpeed.checked && hasValidTime(distPts)){
          mode = 'time';
          timeAnim = prepTimeAnim(distPts);

          if (atEnd) {
            timeAnim.elapsed = 0; // ì²˜ìŒë¶€í„°
          } else if (Number.isFinite(lastAbsMs)) {
            timeAnim.elapsed = clamp(lastAbsMs - timeAnim.t0, 0, timeAnim.totalMs);
          } else {
            timeAnim.elapsed = clamp((distScaled / BASE_DURATION) * timeAnim.totalMs, 0, timeAnim.totalMs);
          }
          animateByTime();
        } else {
          mode = 'distance';
          animateByDistance();
        }
        setPlayButton(true);
        return;
      }



      paused = !paused;
      setPlayButton(!paused);

      // âŸµ [ìˆ˜ì • 1] ì¬ìƒìœ¼ë¡œ ì „í™˜ë˜ëŠ” ìˆœê°„, í”„ë ˆì„ ê¸°ì¤€ ì‹œê°„ ì´ˆê¸°í™”(ì í”„ ë°©ì§€)
      if (!paused) {
        lastFrameTime = performance.now();
        if (!animReq) animReq = requestAnimationFrame(stepRef);
      }
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì• ë‹ˆë©”ì´ì…˜/ë Œë” â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function animateByDistance(){
      if (!marker || distPts.length < 2) return;

      function step(now){
        const dt = now - lastFrameTime; lastFrameTime = now;
        if (!paused) distScaled += dt * (optSpeedCtl.checked ? speed : 1);
        renderAtDistanceProgress(distScaled);

        const done = (distScaled / BASE_DURATION) >= 1;
        if (!done) animReq = requestAnimationFrame(step); else { animReq=null; stepRef=null; setPlayButton(false); }
      }
      stepRef = step;
      animReq = requestAnimationFrame(step);
    }

    // ê±°ë¦¬(ms ìŠ¤ì¼€ì¼) â†’ ë Œë”
    function renderAtDistanceProgress(progressMs){
      if (distCum.length < 2) return;
      const total = totalDistMeters;
      const t = clamp(progressMs / BASE_DURATION, 0, 1);
      const target = t * total;                 // ëª©í‘œ ëˆ„ì ê±°ë¦¬(m)
      curDistMeters = target;                   // â˜… í˜„ì¬ ëˆ„ì ê±°ë¦¬ ê°±ì‹ 

      // ì´ë¶„ íƒìƒ‰ìœ¼ë¡œ êµ¬ê°„ ì°¾ê¸°
      let lo=1, hi=distCum.length-1, idx=1;
      while (lo<=hi){ const mid=(lo+hi)>>1; if (distCum[mid] < target){ idx=mid+1; lo=mid+1; } else { idx=mid; hi=mid-1; } }
      idx = Math.min(idx, distPts.length-1);

      currentIndex = idx;

      const a = distPts[idx-1], b = distPts[idx];
      const segStart = distCum[idx-1];
      const segLen = Math.max(1, distCum[idx]-segStart);
      const segT = clamp((target - segStart) / segLen, 0, 1);

      // a~b ì‚¬ì´ì˜ ë³´ê°„ ì‹œê°
      let curAbsMs = NaN;
      if (isFinite(a.timeMs) && isFinite(b.timeMs)) {
        curAbsMs = a.timeMs + (b.timeMs - a.timeMs) * segT;
      }
      updatePositionAndHud(a, b, segT, curAbsMs, curDistMeters); // â˜… ëˆ„ì ê±°ë¦¬ ì „ë‹¬
    }

    // ê±°ë¦¬(m) ì§ì ‘ ì§€ì • â†’ ë Œë” (ë’¤ë¡œê°€ê¸°ì—ì„œ ì‚¬ìš©)                             // â˜… ë³€ê²½
    function renderAtDistanceMeters(dMeters){
      if (!Number.isFinite(totalDistMeters) || totalDistMeters <= 0) return;
      const clamped = clamp(dMeters, 0, totalDistMeters);
      // ê±°ë¦¬ â†’ ì§„í–‰(ms) ì—­ë³€í™˜
      distScaled = (clamped / totalDistMeters) * BASE_DURATION;
      renderAtDistanceProgress(distScaled);
    }

    function animateByTime(){
      if (!marker || !timeAnim) return;

      function step(now){
        const dt = now - lastFrameTime; lastFrameTime = now;
        if (!paused) timeAnim.elapsed += dt * (optSpeedCtl.checked ? speed : 1);
        const curAbs = timeAnim.t0 + clamp(timeAnim.elapsed, 0, timeAnim.totalMs);
        renderAtAbsTime(curAbs);

        const done = curAbs >= timeAnim.tEnd;
        if (!done) animReq = requestAnimationFrame(step); else { animReq=null; stepRef=null; setPlayButton(false); }
      }
      stepRef = step;
      animReq = requestAnimationFrame(step);
    }

    function renderAtAbsTime(curAbs){
      const tArr = timeAnim.tArr, pts=timeAnim.pts;
      let lo=1, hi=tArr.length-1, idx=1;
      while (lo<=hi){ const mid=(lo+hi)>>1; if (tArr[mid] <= curAbs){ idx=mid+1; lo=mid+1; } else { idx=mid; hi=mid-1; } }
      idx = Math.min(idx, pts.length-1);

      const a = pts[idx-1], b = pts[idx];
      // â†“ ì•„ë˜ 1~2ì¤„ ì¶”ê°€(ì›ë³¸ ì¸ë±ìŠ¤ ë³´ì¡´: a.idx/b.idxëŠ” distPtsì˜ ì¸ë±ìŠ¤)
      if (Number.isFinite(a.idx)) currentIndex = a.idx;
      
      const dtSeg = Math.max(1, b.timeMs - a.timeMs);
      const segT = clamp((curAbs - a.timeMs) / dtSeg, 0, 1);

      // â˜… ì‹œê°„ ëª¨ë“œì—ì„œë„ í˜„ì¬ "ëˆ„ì ê±°ë¦¬(m)"ë¥¼ ì •í™•íˆ ê³„ì‚°
      const segLenMeters = L.latLng(a.lat,a.lng).distanceTo(L.latLng(b.lat,b.lng));
      const startCum = isFinite(a.idx) ? distCum[a.idx] : 0;
      curDistMeters = startCum + segT * segLenMeters;

      updatePositionAndHud(a, b, segT, curAbs, curDistMeters); // â˜… ëˆ„ì ê±°ë¦¬ ì „ë‹¬
    }

    // ìœ„ì¹˜/ì•„ì´ì½˜/HUD ê°±ì‹ 
    function updatePositionAndHud(a,b,segT, currentAbsMs, distMetersNow){
      const lat = a.lat + (b.lat - a.lat) * segT;
      const lng = a.lng + (b.lng - a.lng) * segT;
      const dx  = b.lng - a.lng;
      marker.setIcon(Math.abs(dx) >= 1e-12 ? (dx >= 0 ? iconRight : iconLeft) : ((b.lat - a.lat) >= 0 ? iconRight : iconLeft));

      const elev = lerpNum(a.ele,b.ele,segT);
      const hr   = lerpNum(a.hr, b.hr, segT);
      const cad  = lerpNum(a.cad,b.cad,segT);
      const pwr  = lerpNum(a.pwr,b.pwr,segT);
      const spd  = segmentKmh(a,b);

      const timeTxt = isFinite(currentAbsMs) ? msToClock(currentAbsMs) : "â€”";
      updateHud(spd, hr, elev, cad, pwr, timeTxt, distMetersNow); // â˜… ëˆ„ì ê±°ë¦¬ í¬í•¨

      // â˜… í˜„ì¬ ë Œë”ëœ ì ˆëŒ€ ì‹œê°ì„ ì €ì¥(ì‹œê°„ ëª¨ë“œ ì¬ê°œ ì‹œ ë³µì›ìš©)
      if (isFinite(currentAbsMs)) lastAbsMs = currentAbsMs;

      map.setView([lat,lng], map.getZoom(), { animate:false });
      const c = map.getCenter();
      marker.setLatLng(c);
      hudMarker.setLatLng(c);

      if (miniMarker) miniMarker.setLatLng([lat, lng]);
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€ íŒŒì„œ/ìœ í‹¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function parseGpxPoints(gpxText){
      const out=[];
      try{
        const doc = new DOMParser().parseFromString(gpxText,"application/xml");
        const pts = Array.from(doc.getElementsByTagName("trkpt"));
        for (const pt of pts){
          const lat = parseFloat(pt.getAttribute("lat"));
          const lng = parseFloat(pt.getAttribute("lon") || pt.getAttribute("lng"));
          if (!isFinite(lat) || !isFinite(lng)) continue;

          const timeEl = pt.getElementsByTagName("time")[0];
          const tStr   = timeEl ? timeEl.textContent.trim() : null;
          const timeMs = tStr ? Date.parse(tStr) : NaN;

          const eleEl  = pt.getElementsByTagName("ele")[0];
          const ele    = eleEl ? parseFloat(eleEl.textContent.trim()) : NaN;

          const hr  = firstNumber(pt, ["hr","gpxtpx:hr","ns3:hr"]);
          const cad = firstNumber(pt, ["cad","cadence","gpxtpx:cad","ns3:cad"]);
          const pwr = firstNumber(pt, ["power","Power","gpxtpx:power","ns3:power","watts","ns3:watts"]);

          // â˜… ì›ë³¸ ì¸ë±ìŠ¤ë¥¼ ë³´ì¡´í•´ ì‹œê°„ ëª¨ë“œì—ì„œ ëˆ„ì ê±°ë¦¬ ê³„ì‚°ì— ì‚¬ìš©
          out.push({ lat,lng,timeMs,ele,hr,cad,pwr, idx: out.length });                  // â˜… ë³€ê²½
        }
      }catch(e){ console.warn("[GPX] íŒŒì‹± ì‹¤íŒ¨:", e); }
      return out;
    }

    function buildCumDist(pts){
      const acc=[0]; let sum=0;
      for (let i=1;i<pts.length;i++){
        const a=L.latLng(pts[i-1].lat, pts[i-1].lng);
        const b=L.latLng(pts[i].lat,   pts[i].lng);
        sum += a.distanceTo(b);
        acc.push(sum);
      }
      return acc;
    }

    // í˜„ì¬ ëˆ„ì ê±°ë¦¬(m)ë¥¼ í•­ìƒ ì•ˆì „í•˜ê²Œ ì–»ê¸° (curDistMetersê°€ NaN/ì´ˆê¸°ê°’ì´ì–´ë„ ë™ì‘)
    function getCurrentDistMeters(){
      if (Number.isFinite(curDistMeters) && curDistMeters >= 0) return curDistMeters;
      if (Number.isFinite(totalDistMeters) && totalDistMeters > 0){
        const t = clamp(distScaled / BASE_DURATION, 0, 1);
        return t * totalDistMeters;
      }
      return 0;
    }

    // â˜… ì¶”ê°€: í˜„ì¬ê°€ 'ì™„ì£¼' ìƒíƒœì¸ì§€ íŒì •(ì†Œìˆ˜ ì˜¤ì°¨ í—ˆìš©)
    function isAtEnd(){
      return Number.isFinite(totalDistMeters)
          && totalDistMeters > 0
          && (getCurrentDistMeters() >= totalDistMeters - 1e-3);
    }


    // ëˆ„ì ê±°ë¦¬ ë°°ì—´ì—ì„œ target ì´í•˜ì˜ "ì•ˆì „í•œ" ì¸ë±ìŠ¤ë¥¼ ì°¾ëŠ”ë‹¤.
    // - hintIdxê°€ ìˆìœ¼ë©´ ê·¸ë³´ë‹¤ "ì‘ì€ ì¸ë±ìŠ¤"ë¥¼ ê°•ì œ(ì§„ì§œ ë’¤ë¡œ ì´ë™ ë³´ì¥)
    // - plateau(ì¤‘ë³µ ëˆ„ì ê±°ë¦¬)ì—ì„œëŠ” ë™ì¼ê°’ êµ¬ê°„ì˜ "ê°€ì¥ ì²˜ìŒ ì¸ë±ìŠ¤"ë¡œ ì´ë™
    function findIndexAtDistance(distCum, target, hintIdx) {
      if (!distCum || !distCum.length) return -1;
      const EPS = 1e-3;

      // í‘œì¤€ ì´ì§„íƒìƒ‰: distCum[mid] <= target ì¸ ê°€ì¥ í° mid
      let lo = 0, hi = distCum.length - 1, ans = 0;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        if (distCum[mid] <= target + EPS) { ans = mid; lo = mid + 1; }
        else { hi = mid - 1; }
      }

      // plateauì˜ ì‹œì‘ì ìœ¼ë¡œ ì´ë™
      const val = distCum[ans];
      while (ans > 0 && Math.abs(distCum[ans - 1] - val) <= EPS) ans--;

      // íŒíŠ¸ê°€ ìˆìœ¼ë©´ ë°˜ë“œì‹œ hintIdxë³´ë‹¤ ì‘ê²Œ ë³´ì •í•´ ì‹¤ì œ "ë’¤ë¡œ" ë³´ì¥
      if (Number.isInteger(hintIdx) && ans >= hintIdx) {
        ans = Math.max(0, hintIdx - 1);
        const v2 = distCum[ans];
        while (ans > 0 && Math.abs(distCum[ans - 1] - v2) <= EPS) ans--;
      }
      return ans;
    }

    // ì§„í–‰ì¤‘ ì• ë‹ˆë©”ì´ì…˜ í”„ë ˆì„ì´ ìˆìœ¼ë©´ ì·¨ì†Œ(ë’¤ë¡œê°€ê¸° ìˆœê°„ ê²½í•© ë°©ì§€)
    function cancelAnimFrameIfAny() {
      try { if (animReq) { cancelAnimationFrame(animReq); animReq = null; } } catch(e){}
    }

    function renderAtIndex(i){
      if (!Array.isArray(distCum) || distCum.length === 0) return;
      i = Math.max(0, Math.min(i, distCum.length - 1));
      renderAtDistanceMeters(distCum[i]);
      currentIndex = i; // ì¸ë±ìŠ¤ ê°±ì‹ 
    }


    




    function prepTimeAnim(pts){
      const valid = pts.filter(p=>isFinite(p.timeMs)).sort((a,b)=>a.timeMs-b.timeMs);
      if (valid.length < 2) return null;
      const t0 = valid[0].timeMs, tEnd = valid[valid.length-1].timeMs;
      return { pts:valid, t0, tEnd, totalMs:Math.max(1, tEnd - t0), tArr:valid.map(p=>p.timeMs), elapsed:0 };
    }

    function updateHud(spdKmh, hr, ele, cad, pwr, timeText, distMeters){
      const $=(id)=>document.getElementById(id);
      const fmt=(v,u,d=0)=> (isFinite(v) ? (v.toFixed(d)+u) : "â€”");
      const speedTxt = fmt(spdKmh,"km/h",1);
      const hrTxt    = isFinite(hr)  ? Math.round(hr)  + " bpm" : "â€”";
      const eleTxt   = isFinite(ele) ? Math.round(ele) + " m"   : "â€”";
      const cadTxt   = isFinite(cad) ? Math.round(cad) + " rpm" : "â€”";
      const pwrTxt   = isFinite(pwr) ? Math.round(pwr) + " W"   : "â€”";
      const distTxt  = isFinite(distMeters) ? (distMeters/1000).toFixed(2) + " km" : "â€”"; // â˜… ë³€ê²½

      const hs=$("hudSpd");  if (hs && hs.textContent!==speedTxt) hs.textContent=speedTxt;
      const ht=$("hudTime"); if (ht && ht.textContent!==timeText) ht.textContent=timeText;
      const hh=$("hudHr");   if (hh && hh.textContent!==hrTxt)   hh.textContent=hrTxt;
      const he=$("hudEle");  if (he && he.textContent!==eleTxt)  he.textContent=eleTxt;
      const hc=$("hudCad");  if (hc && hc.textContent!==cadTxt)  hc.textContent=cadTxt;
      const hp=$("hudPwr");  if (hp && hp.textContent!==pwrTxt)  hp.textContent=pwrTxt;
      const hd=$("hudDist"); if (hd && hd.textContent!==distTxt) hd.textContent=distTxt; // â˜… ë³€ê²½
    }

    function msToClock(ms){
      const d = new Date(ms);
      const hh = d.getHours().toString().padStart(2,'0');
      const mm = d.getMinutes().toString().padStart(2,'0');
      const ss = d.getSeconds().toString().padStart(2,'0');
      return `${hh}:${mm}:${ss}`;
    }

    function decideInitialIcon(pts){
      if (!pts || pts.length < 2) return iconRight;
      const dx = pts[1].lng - pts[0].lng;
      return dx >= 0 ? iconRight : iconLeft;
    }
    function hasValidTime(pts){ return pts.filter(p=>isFinite(p.timeMs)).length >= 2; }
    function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
    function lerpNum(a,b,t){ const A=Number(a), B=Number(b); if (isFinite(A)&&isFinite(B)) return A+(B-A)*t; if (isFinite(A)) return A; if (isFinite(B)) return B; return NaN; }
    function segmentKmh(a,b){ const dt=(b.timeMs-a.timeMs)/1000; if (!isFinite(dt)||dt<=0) return NaN; const d=L.latLng(a.lat,a.lng).distanceTo(L.latLng(b.lat,b.lng)); return (d/dt)*3.6; }
    function firstNumber(el,names){
      for (const n of names){ const e=el.getElementsByTagName(n)[0]; if (e && e.textContent!=null){ const v=parseFloat(e.textContent.trim()); if (isFinite(v)) return v; } }
      const candidates=new Set(["hr","cad","cadence","power","watts"]);
      const all=el.getElementsByTagName("*");
      for (let i=0;i<all.length;i++){
        const node=all[i]; const local=(node.localName||node.nodeName||"").toLowerCase();
        if (candidates.has(local)){ const v=parseFloat(node.textContent.trim()); if (isFinite(v)) return v; }
      }
      return NaN;
    }

    // â˜… ê°’ â†’ 0~1 ì •ê·œí™”
    function norm01(v, min, max){
        if (!isFinite(v) || !isFinite(min) || !isFinite(max) || max <= min) return NaN;
        return Math.min(1, Math.max(0, (v - min) / (max - min)));
    }

    // â˜… 0~1ë¥¼ HSL ê·¸ë¼ë°ì´ì…˜ìœ¼ë¡œ ë³€í™˜(íŒŒë‘â†’ì²­ë¡â†’ì´ˆë¡â†’ë…¸ë‘â†’ì£¼í™©â†’ë¹¨ê°•)
    function hueRamp01(t){
        if (!isFinite(t)) return '#999999';
        const h = (1 - t) * 240; // 240(íŒŒë‘) â†’ 0(ë¹¨ê°•)
        return `hsl(${h.toFixed(1)} 90% 50%)`;
    }

    // â˜… ëª¨ë“œë³„ ê°’ ì¶”ì¶œ(ì„¸ê·¸ë¨¼íŠ¸ a->b, segTëŠ” ì‚¬ìš© ì•ˆ í•´ë„ ë¨)
    function metricValue(mode, a, b){
        switch(mode){
            case 'ele': return (isFinite(a.ele)||isFinite(b.ele)) ? lerpNum(a.ele, b.ele, 0.5) : NaN;
            case 'hr' : return (isFinite(a.hr) ||isFinite(b.hr )) ? lerpNum(a.hr , b.hr , 0.5) : NaN;
            case 'cad': return (isFinite(a.cad)||isFinite(b.cad)) ? lerpNum(a.cad, b.cad, 0.5) : NaN;
            case 'pwr': return (isFinite(a.pwr)||isFinite(b.pwr)) ? lerpNum(a.pwr, b.pwr, 0.5) : NaN;
            case 'spd': {
            const v = segmentKmh(a,b);
            return isFinite(v) ? v : NaN;
            }
            default: return NaN;
        }
    }

    // â˜… ê° í•­ëª©ì˜ min/max ê³„ì‚°(ì†ë„ëŠ” segmentKmhë¡œ)
    function computeStatRange(pts){
        const acc = { ele:[], spd:[], hr:[], cad:[], pwr:[] };
        for (let i=1;i<pts.length;i++){
            const a=pts[i-1], b=pts[i];
            const spd = segmentKmh(a,b);
            if (isFinite(spd)) acc.spd.push(spd);
            if (isFinite(a.ele)) acc.ele.push(a.ele);
            if (isFinite(b.ele)) acc.ele.push(b.ele);
            if (isFinite(a.hr )) acc.hr .push(a.hr );
            if (isFinite(b.hr )) acc.hr .push(b.hr );
            if (isFinite(a.cad)) acc.cad.push(a.cad);
            if (isFinite(b.cad)) acc.cad.push(b.cad);
            if (isFinite(a.pwr)) acc.pwr.push(a.pwr);
            if (isFinite(b.pwr)) acc.pwr.push(b.pwr);
        }
        for (const k of Object.keys(statRange)){
            const arr = acc[k];
            if (!arr.length){ statRange[k] = {min:NaN, max:NaN}; continue; }
            statRange[k] = { min: Math.min(...arr), max: Math.max(...arr) };
        }
    }

    // â˜… í˜„ì¬ ëª¨ë“œ/ê°’ì„ ì»¬ëŸ¬(hex)ë¡œ
    function colorFor(mode, a, b){
        if (mode==='mono') return '#ef4444';
        const rng = statRange[mode] || {min:NaN, max:NaN};
        const v   = metricValue(mode, a, b);
        const t   = norm01(v, rng.min, rng.max);
        return hueRamp01(t);
    }

    // â˜… ì„¸ê·¸ë¨¼íŠ¸ í´ë¦¬ë¼ì¸ ìƒì„±/ê°±ì‹ 
    function buildGradientRoute(mode){
        if (!Array.isArray(distPts) || distPts.length < 2) return;

        // ì´ì „ ê·¸ë£¹ ì œê±°
        if (gradientGroup){ map.removeLayer(gradientGroup); gradientGroup=null; }

        // Canvas ë Œë”ëŸ¬ ê¶Œì¥(ì„±ëŠ¥)
        const renderer = L.canvas({ padding:0.5 });

        gradientGroup = L.layerGroup();
        for (let i=1;i<distPts.length;i++){
            const a = distPts[i-1], b = distPts[i];
            const col = colorFor(mode, a, b);
            const seg = L.polyline([[a.lat,a.lng],[b.lat,b.lng]], {
                pane:'routePane',
                color: col, weight: 5, opacity: 0.95, lineCap:'round', renderer
            });

            gradientGroup.addLayer(seg);
        }
        gradientGroup.addTo(map);

    // ì˜¤ë²„ë·°ë„ ë‹¨ìƒ‰ í‚¤ ìœ ì§€(ì›í•˜ë©´ ë™ì¼ ìŠ¤ì¼€ì¼ ì „íŒŒ ê°€ëŠ¥)
    }



    function resetAll(){
      if (animReq){ cancelAnimationFrame(animReq); animReq=null; }
      stepRef=null; paused=false; lastFrameTime=0; mode='distance';
      if (marker){ map.removeLayer(marker); marker=null; }
      if (hudMarker){ map.removeLayer(hudMarker); hudMarker=null; }
      if (gpxLayer){ map.removeLayer(gpxLayer); gpxLayer=null; }
      distPts=[]; distCum=[]; distScaled=0; timeAnim=null;
      speed=1; speedRange.value="1"; speedValue.textContent="1.0";
      fitBtn.disabled = true; playBtn.disabled = true; backBtn.disabled = true;

      totalDistMeters = 0;   // â˜… ë³€ê²½
      curDistMeters = 0;     // â˜… ë³€ê²½
      currentIndex = 0;

      if (miniRoute){ miniMap.removeLayer(miniRoute); miniRoute=null; }
      if (miniMarker){ miniMap.removeLayer(miniMarker); miniMarker=null; }
      miniBounds=null;

      // â˜… ì¶”ê°€: ê·¸ë¼ë°ì´ì…˜ ë¼ì¸ ê·¸ë£¹ ì œê±°
      if (gradientGroup){ map.removeLayer(gradientGroup); gradientGroup=null; }
    }
  </script>
</body>
</html>
